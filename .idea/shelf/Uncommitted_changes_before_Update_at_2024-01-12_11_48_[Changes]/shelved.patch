Index: app/src/main/java/com/example/racoonsquash/PongGameView.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.racoonsquash\r\n\r\nimport android.content.Context\r\nimport android.graphics.Canvas\r\nimport android.graphics.Color\r\nimport android.graphics.Paint\r\nimport android.graphics.Path\r\nimport android.graphics.Rect\r\nimport android.graphics.Typeface\r\nimport android.media.MediaPlayer\r\nimport android.view.MotionEvent\r\nimport android.view.SurfaceHolder\r\nimport android.view.SurfaceView\r\nimport android.widget.ImageButton\r\nimport android.widget.Toast\r\nimport androidx.core.view.isVisible\r\nimport kotlin.math.pow\r\nimport kotlin.math.sqrt\r\nimport kotlin.random.Random\r\n\r\n\r\nclass PongGameView(context: Context, private val userName: String) : SurfaceView(context), SurfaceHolder.Callback, Runnable {\r\n    var thread: Thread? = null\r\n    var running = false\r\n    var lineColor: Paint\r\n    private var leftBoundaryPath: Path? = null\r\n    private var rightBoundaryPath: Path? = null\r\n    var touchColor: Paint\r\n    var scorePaint: Paint\r\n    val mediaPlayer = MediaPlayer.create(context, R.raw.pongbreakout3)\r\n\r\n    var isGameOver = false\r\n    var isGameWon = false\r\n    lateinit var textGameWonPaint: Paint\r\n    private var textGameOverPaint: Paint\r\n\r\n    //    private var scorePlayerTop = 0\r\n//    private var scorePlayerBottom = 0\r\n    private val blockList: MutableList<BreakoutBlock> = mutableListOf()\r\n    private val xPositionList: MutableList<Float> = mutableListOf()\r\n    private val yPositionList: MutableList<Float> = mutableListOf()\r\n    lateinit var ballPong: BallPong\r\n    var bounds = Rect()\r\n    var mHolder: SurfaceHolder? = holder\r\n\r\n    private lateinit var pauseButton: ImageButton\r\n//    private val initialBallPosX = 500f\r\n//    private val initialBallPosY = 700f\r\n\r\n    private var score = 0\r\n    private lateinit var paddle: PaddlePong\r\n    private lateinit var topPaddle: PaddlePong\r\n    private val initialBallPosXForTop = 500f\r\n    private val initialBallPosYForTop = 1300f\r\n    private val initialBallPosXForBottom = 300f\r\n    private val initialBallPosYForBottom = 500f\r\n    private var lives = 3// Antal liv\r\n\r\n\r\n    private var isPaused = false\r\n\r\n    private val bounceSpeedXFactor = 10.0f  // Justera detta värde efter behov\r\n\r\n    val soundEffect = SoundEffect(context)\r\n\r\n    init {\r\n        if (mHolder != null) {\r\n            mHolder?.addCallback(this)\r\n        }\r\n\r\n        lineColor = Paint().apply {\r\n            color = Color.CYAN\r\n            style = Paint.Style.STROKE\r\n            strokeWidth = 10f\r\n\r\n            scorePaint = Paint().apply {\r\n                color = Color.GREEN\r\n                alpha = 200\r\n                textSize = 60.0F\r\n                typeface = Typeface.create(\"serif-monospace\", Typeface.BOLD)\r\n            }\r\n            textGameOverPaint = Paint().apply {\r\n                color = Color.RED\r\n                alpha = 200\r\n                textSize = 60.0F\r\n                typeface = Typeface.create(\"serif-monospace\", Typeface.BOLD)\r\n            }\r\n            textGameWonPaint = Paint().apply {\r\n                color = Color.GREEN\r\n                alpha = 200\r\n                textSize = 60.0F\r\n                typeface = Typeface.create(\"serif-monospace\", Typeface.BOLD)\r\n            }\r\n\r\n            // Enbart för att synliggöra gränserna\r\n            lineColor = Paint().apply {\r\n                color = Color.MAGENTA\r\n                style = Paint.Style.STROKE\r\n                strokeWidth = 10f\r\n            }\r\n            touchColor = Paint().apply {\r\n                color = Color.RED\r\n                style = Paint.Style.STROKE\r\n                strokeWidth = 50f\r\n            }\r\n        }\r\n        setup()\r\n    }\r\n\r\n    private val screenWidth = resources.displayMetrics.widthPixels\r\n    private val screenHeight = resources.displayMetrics.heightPixels\r\n\r\n    private fun setup() {\r\n        mediaPlayer.isLooping= true\r\n        mediaPlayer.start()\r\n        ballPong = BallPong(context, 150f, 150f, 30f, 15f, 15f, 0)\r\n\r\n        paddle = PaddlePong(\r\n            context,\r\n            screenWidth / 2f,\r\n            screenHeight - 300f,  // for bottom paddle (Had to change for the smaller size) // JH\r\n            180f,\r\n            20f,\r\n            Color.parseColor(\"#FFFF00\")\r\n        )\r\n        topPaddle = PaddlePong(\r\n            context,\r\n            screenWidth / 2f,\r\n            50f,  // for top paddle\r\n            180f,\r\n            20f,\r\n            Color.parseColor(\"#FFFF00\")\r\n        )\r\n    }\r\n\r\n\r\n    fun setupButtons(pauseButton: ImageButton, playButton: ImageButton) {\r\n        pauseButton.setOnClickListener {\r\n            this.pauseButton = pauseButton\r\n            if (!isGameWon && lives > 0) {\r\n                isPaused = true\r\n                playButton.isVisible = true\r\n                pauseButton.isVisible = false\r\n            }\r\n        }\r\n        playButton.setOnClickListener {\r\n            if (!isGameWon && lives > 0) {\r\n                isPaused = false\r\n                playButton.isVisible = false\r\n                pauseButton.isVisible = true\r\n            }\r\n        }\r\n    }\r\n\r\n    fun restartGame() {\r\n        if (running) {\r\n            // Tömma listan kan orsaka bug? Annat sätt att lösa det på?\r\n            blockList.clear()\r\n            buildBreakoutBlocks()\r\n\r\n            score = 0\r\n            lives = 3\r\n\r\n            setup()\r\n\r\n            if (isPaused) {\r\n                isPaused = false\r\n                pauseButton.isVisible = true\r\n            }\r\n\r\n        } else {\r\n            Toast.makeText(this.context, \"Cant restart at game over...\", Toast.LENGTH_LONG).show()\r\n        }\r\n    }\r\n\r\n    override fun onTouchEvent(event: MotionEvent): Boolean {\r\n        when (event.action) {\r\n            MotionEvent.ACTION_DOWN, MotionEvent.ACTION_MOVE -> {\r\n                // Move both paddles in sync based on the touch input\r\n                val newX = event.x\r\n                paddle.move(newX)\r\n                topPaddle.move(newX)\r\n\r\n                performClick()\r\n            }\r\n        }\r\n        return true\r\n    }\r\n\r\n    override fun performClick(): Boolean {\r\n        // Call the super implementation to handle the click event\r\n        super.performClick()\r\n        // Return true if the click event is handled\r\n        return true\r\n    }\r\n\r\n\r\n    fun start() {\r\n\r\n        running = true\r\n        thread = Thread(this) //en trad har en konstruktor som tar in en runnable,\r\n        // vilket sker i denna klass se rad 10\r\n        thread?.start()\r\n\r\n    }\r\n\r\n    fun stop() {\r\n        running = false\r\n\r\n        mediaPlayer.release()\r\n\r\n        try {\r\n            thread?.interrupt() //join betyder att huvudtraden komemr vanta in att traden dor ut av sig sjalv\r\n        } catch (e: InterruptedException) {\r\n            e.printStackTrace()\r\n        }\r\n    }\r\n\r\n\r\n    private fun loseLife() {\r\n        lives--\r\n        if (lives <= 0) {\r\n            soundEffect.play(2)\r\n            isGameOver = true\r\n        } else {\r\n            soundEffect.play(8)\r\n        }\r\n    }\r\n\r\n\r\n    fun update() {\r\n        checkWinCondition()\r\n        ballPong.update()\r\n        checkBallBlockCollision()\r\n        paddle.update()\r\n        topPaddle.update()\r\n        val screenHeight = height // Höjden på skärmen\r\n        if (lives <= 0) {\r\n            stop()\r\n        }\r\n\r\n\r\n        // Check collision with the bottom paddle\r\n        if (isBallCollidingWithPaddle(ballPong, paddle)) {\r\n            soundEffect.play(0)\r\n            handleBallPaddleCollision(ballPong, paddle)\r\n        }\r\n\r\n        // Check collision with the top paddle\r\n        if (isBallCollidingWithPaddle(ballPong, topPaddle)) {\r\n            soundEffect.play(0)\r\n            handleBallPaddleCollision(ballPong, topPaddle)\r\n        }\r\n\r\n\r\n        if (ballPong.ballPositionY < -ballPong.ballSize) {\r\n\r\n\r\n\r\n            resetBallPosition()\r\n\r\n        } else if (ballPong.ballPositionY > screenHeight + ballPong.ballSize) {\r\n\r\n\r\n            resetBallPosition()\r\n\r\n\r\n        } else if (ballPong.ballPositionX < 0) {\r\n\r\n\r\n            score = 0\r\n\r\n        }\r\n        if (checkWinCondition() == true) {\r\n            isGameWon = true\r\n            soundEffect.play(7)\r\n\r\n        }\r\n\r\n\r\n        resetBallPosition()\r\n    }\r\n\r\n\r\n    private fun checkWinCondition(): Boolean {\r\n\r\n        return blockList.isEmpty()\r\n    }\r\n\r\n    private fun resetBallPosition() {\r\n        // Placera bollen på olika startpositioner beroende på var den åker ut\r\n\r\n        if (ballPong.ballPositionY < -ballPong.ballSize) {\r\n            loseLife()\r\n            Thread.sleep(0)\r\n            ballPong.ballPositionX = initialBallPosXForTop\r\n            ballPong.ballPositionY = initialBallPosYForTop\r\n        } else if (ballPong.ballPositionY > screenHeight - ballPong.ballSize) {\r\n            loseLife()\r\n            Thread.sleep(0)\r\n            ballPong.ballPositionX = initialBallPosXForBottom\r\n            ballPong.ballPositionY = initialBallPosYForBottom\r\n        }\r\n    }\r\n\r\n\r\n    override fun run() {\r\n        while (running) {\r\n            if (!isPaused) {\r\n                update()\r\n                drawGameBounds(holder)\r\n                ballPong.checkBounds(bounds)\r\n            }\r\n        }\r\n    }\r\n\r\n    override fun surfaceCreated(holder: SurfaceHolder) {\r\n        val blockWidth = 175f\r\n        val blockHeight = 50f\r\n        val centerX = (width / 2) - (blockWidth / 2)\r\n        val centerY = (height / 2) - (blockHeight / 2)\r\n        setup()\r\n\r\n        // Column positions\r\n        columnBlockPosition(centerX - 400f)\r\n        columnBlockPosition(centerX - 200f)\r\n        columnBlockPosition(centerX)\r\n        columnBlockPosition(centerX + 200f)\r\n        columnBlockPosition(centerX + 400f)\r\n\r\n        // Row positions\r\n        rowBlockPosition(centerY - 140f)\r\n        rowBlockPosition(centerY - 70f)\r\n        rowBlockPosition(centerY)\r\n        rowBlockPosition(centerY + 70f)\r\n        rowBlockPosition(centerY + 140f)\r\n\r\n        buildBreakoutBlocks()\r\n    }\r\n\r\n    override fun surfaceChanged(holder: SurfaceHolder, format: Int, width: Int, height: Int) {\r\n        leftBoundaryPath = createBoundaryPathLeft(width, height)\r\n        rightBoundaryPath = createBoundaryPathRight(width, height)\r\n        bounds = Rect(0, 0, width, height)\r\n        start()\r\n\r\n    }\r\n\r\n    override fun surfaceDestroyed(holder: SurfaceHolder) {\r\n        stop()\r\n    }\r\n\r\n    private fun columnBlockPosition(xPosition: Float) {\r\n        xPositionList.add(xPosition)\r\n    }\r\n\r\n    private fun rowBlockPosition(yPosition: Float) {\r\n        yPositionList.add(yPosition)\r\n    }\r\n\r\n    private fun deleteBlockInList(block: BreakoutBlock): Boolean {\r\n\r\n        blockList.remove(block)\r\n        return blockList.isEmpty()\r\n    }\r\n\r\n    private fun addBlockInList(block: BreakoutBlock) {\r\n        blockList.add(block)\r\n    }\r\n\r\n\r\n    // Adding blocks in list in rows and columns\r\n    private fun buildBreakoutBlocks() {\r\n        var randomBitmap = Random.nextInt(0, 3)\r\n        val blockWidth = 175f\r\n        val blockHeight = 50f\r\n\r\n        for (y in yPositionList) {\r\n            for (x in xPositionList) {\r\n                addBlockInList(\r\n                    BreakoutBlock(\r\n                        this.context, x, y, x + blockWidth, y + blockHeight,\r\n                        randomBitmap\r\n                    )\r\n                )\r\n                randomBitmap = Random.nextInt(0, 3)\r\n            }\r\n        }\r\n    }\r\n\r\n    private fun checkBallBlockCollision() {\r\n        for (block in blockList) {\r\n            if (onBlockCollision(block, ballPong)) {\r\n                ballPong.ballSpeedY *= -1\r\n\r\n                score++\r\n\r\n                soundEffect.play(3)\r\n\r\n                isGameWon = deleteBlockInList(block)\r\n\r\n                break\r\n            }\r\n\r\n        }\r\n\r\n\r\n    }\r\n\r\n\r\n    private fun onBlockCollision(block: BreakoutBlock, ball: BallPong): Boolean {\r\n        // CommonX sparar bollens x-position om den befinner sig inom blockets x-position\r\n        val commonX = if (ball.ballPositionX < block.posX) {\r\n            block.posX\r\n        } else if (ball.ballPositionX > block.width) {\r\n            block.width\r\n        } else {\r\n            ball.ballPositionX\r\n        }\r\n\r\n        // CommonY sparar bollens y-position om den befinner sig inom blockets y-position\r\n        val commonY = if (ball.ballPositionY < block.posY) {\r\n            block.posY\r\n        } else if (ball.ballPositionY > block.height) {\r\n            block.height\r\n        } else {\r\n            ball.ballPositionY\r\n        }\r\n\r\n        // Här räknas distansen ut. Exempel, om bollens x-position är 50 och commonX\r\n        // är samma, dvs. 50 så blir x-distansens 0. Samma gäller för Y.\r\n        val distance =\r\n            sqrt(\r\n                (ball.ballPositionX - commonX).toDouble()\r\n                    .pow(2.0) + (ball.ballPositionY - commonY).toDouble()\r\n                    .pow(2.0)\r\n            )\r\n\r\n        // Returnerar true när distansen är 0 och drar bort bollens size.\r\n        return distance < ball.ballSize\r\n\r\n    }\r\n\r\n    fun drawGameBounds(holder: SurfaceHolder) {\r\n        val canvas: Canvas? = holder.lockCanvas()\r\n\r\n        canvas?.drawColor(Color.BLACK)\r\n\r\n        val livesText = \"Lives: $lives\"\r\n        canvas?.drawText(livesText, 20f, 100f, scorePaint)\r\n\r\n        rightBoundaryPath?.let {\r\n            if (isGameWon) {\r\n                canvas?.drawText(\r\n                    \"CONGRATZ\",\r\n                    canvas.width.toFloat() / 3,\r\n                    canvas.height.toFloat() - 300,\r\n                    textGameWonPaint\r\n                )\r\n                // Save score\r\n                val sharedPreferencesManager : DataManager = SharedPreferencesManager(context)\r\n                sharedPreferencesManager.addNewScore(DataManager.Score(this.userName, score, DataManager.Game.BREAKOUT))\r\n//                    stop()\r\n            }\r\n\r\n            if (isGameOver) {\r\n                canvas?.drawText(\r\n                    \"GAME OVER\",\r\n                    canvas.width.toFloat() / 3,\r\n                    canvas.height.toFloat() - 300,\r\n                    textGameOverPaint\r\n                )\r\n                // Save score\r\n                val sharedPreferencesManager: DataManager = SharedPreferencesManager(context)\r\n                sharedPreferencesManager.addNewScore(\r\n                    DataManager.Score(\r\n                        this.userName,\r\n                        score,\r\n                        DataManager.Game.BREAKOUT\r\n                    )\r\n                )\r\n            }\r\n            canvas?.drawPath(it, lineColor)\r\n            if (ballPong.ballPositionY < 0 - ballPong.ballSize) {\r\n                canvas?.drawPath(it, touchColor)\r\n                canvas?.drawText(\r\n                    \"Score: $score\",\r\n                    canvas.width.toFloat() - 400,\r\n                    0f + 100,\r\n                    textGameOverPaint\r\n                )\r\n\r\n\r\n            } else {\r\n                // Placera text\r\n                canvas?.drawText(\r\n                    \"Score: $score\",\r\n                    canvas.width.toFloat() - 400,\r\n                    0f + 100,\r\n                    scorePaint\r\n                )\r\n            } //DENNA MÅSTE VARA KVAR:\r\n            if (lives <= 0)\r\n                canvas?.drawText(\r\n                    \"GAME OVER\",\r\n                    canvas.width.toFloat() / 3,\r\n                    canvas.height.toFloat() - 300,\r\n                    textGameOverPaint\r\n                )\r\n\r\n        }\r\n\r\n        leftBoundaryPath?.let {\r\n            canvas?.drawPath(it, lineColor)\r\n        }\r\n\r\n        // Draw the paddles\r\n        paddle.draw(canvas!!)\r\n        topPaddle.draw(canvas)\r\n\r\n        //Draw all blocks\r\n        for (block in blockList) {\r\n            block.draw(canvas)\r\n        }\r\n\r\n\r\n        ballPong.draw(canvas)\r\n        holder.unlockCanvasAndPost(canvas)\r\n\r\n        if (isGameWon) {\r\n            stop()\r\n\r\n        }\r\n    }\r\n\r\n    private fun isBallCollidingWithPaddle(ball: BallPong, paddle: PaddlePong): Boolean {\r\n        // Check if the ball is within the horizontal bounds of the paddle\r\n        val horizontalCollision =\r\n            ball.ballPositionX + ball.ballSize > paddle.padPositionX - paddle.width / 2 &&\r\n                    ball.ballPositionX - ball.ballSize < paddle.padPositionX + paddle.width / 2\r\n\r\n        // Check if the ball is within the vertical bounds of the paddle\r\n        val verticalCollision =\r\n            ball.ballPositionY + ball.ballSize > paddle.padPositionY - paddle.height / 2 &&\r\n                    ball.ballPositionY - ball.ballSize < paddle.padPositionY + paddle.height / 2\r\n\r\n        return horizontalCollision && verticalCollision\r\n    }\r\n\r\n    private fun handleBallPaddleCollision(ball: BallPong, paddle: PaddlePong) {\r\n        // Invertera Y-hastigheten för att bollen ska studsa\r\n        ball.ballSpeedY = -ball.ballSpeedY\r\n\r\n        // Justera X-hastigheten baserat på träffpunkten på paddeln\r\n        val impactPoint = (ball.ballPositionX - paddle.padPositionX) / (paddle.width / 2)\r\n\r\n        ball.ballSpeedX = bounceSpeedXFactor * impactPoint\r\n    }\r\n\r\n    //     Enbart spelplan med linje för syns skull, vänster sidolinje.\r\n    private fun createBoundaryPathLeft(width: Int, height: Int): Path {\r\n        val pathLeft = Path()\r\n\r\n        pathLeft.moveTo(0f, 0f)\r\n        pathLeft.lineTo(0f, height.toFloat())\r\n\r\n        return pathLeft\r\n    }\r\n\r\n    // Enbart spelplan med linje för syns skull, höger sidolinje.\r\n    private fun createBoundaryPathRight(width: Int, height: Int): Path {\r\n        val pathRight = Path()\r\n\r\n        pathRight.moveTo(width.toFloat(), 0f)\r\n        pathRight.lineTo(width.toFloat(), height.toFloat())\r\n\r\n        return pathRight\r\n    }\r\n//    private fun updateScore(): Int {\r\n//        score++\r\n//        return score\r\n//    }\r\n//    private fun updateScoreTop(): Int {\r\n//        scorePlayerTop++\r\n//        return scorePlayerTop\r\n//    }\r\n//\r\n//    private fun updateScoreBottom(): Int {\r\n//        scorePlayerBottom++\r\n//        return scorePlayerBottom\r\n//    }\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/racoonsquash/PongGameView.kt b/app/src/main/java/com/example/racoonsquash/PongGameView.kt
--- a/app/src/main/java/com/example/racoonsquash/PongGameView.kt	(revision aafe0228f59aa0e6292c61bff020eb901850b797)
+++ b/app/src/main/java/com/example/racoonsquash/PongGameView.kt	(date 1705055241565)
@@ -31,7 +31,7 @@
 
     var isGameOver = false
     var isGameWon = false
-    lateinit var textGameWonPaint: Paint
+    var textGameWonPaint: Paint
     private var textGameOverPaint: Paint
 
     //    private var scorePlayerTop = 0
@@ -338,6 +338,7 @@
         buildBreakoutBlocks()
     }
 
+
     override fun surfaceChanged(holder: SurfaceHolder, format: Int, width: Int, height: Int) {
         leftBoundaryPath = createBoundaryPathLeft(width, height)
         rightBoundaryPath = createBoundaryPathRight(width, height)
Index: app/src/main/java/com/example/racoonsquash/SquashGameView.kt
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.example.racoonsquash\r\n\r\nimport android.annotation.SuppressLint\r\nimport android.content.Context\r\nimport android.graphics.Canvas\r\nimport android.graphics.Color\r\nimport android.graphics.Paint\r\nimport android.graphics.Path\r\nimport android.graphics.Rect\r\nimport android.graphics.Typeface\r\nimport android.view.MotionEvent\r\nimport android.view.SurfaceHolder\r\nimport android.view.SurfaceView\r\n\r\n\r\nclass SquashGameView(context: Context, private val userName: String) : SurfaceView(context), SurfaceHolder.Callback, Runnable {\r\n    var thread: Thread? = null\r\n    private var running = false\r\n    lateinit var ballSquash: BallSquash\r\n    lateinit var squashPad: SquashPad\r\n    private var lineColor: Paint\r\n    private var touchColor: Paint\r\n    private var scorePaint: Paint\r\n    private var textGameOverPaint: Paint\r\n    private var score: Int = 0;\r\n    private var isPaused = false\r\n    val soundEffect = SoundEffect(context) // Behöver komma åt i activity för att frigöra resurser.\r\n\r\n    //Path-klass ritar ett \"spår\" från en punkt moveTo() till nästa punkt lineTo()\r\n    private var gameBoundaryPath: Path? = null\r\n\r\n    var bounds = Rect() //for att kunna studsa m vaggarna\r\n    var mHolder: SurfaceHolder? = holder\r\n\r\n    private var buttonPauseRect :Rect? = null\r\n    private val buttonPausePaint = Paint().apply {\r\n        //This could be transparent if no rectangle is wanted to be shown\r\n        color = Color.YELLOW\r\n        alpha = 100\r\n    }\r\n    private val buttonPauseTextPaint = Paint().apply {\r\n        color = Color.WHITE\r\n        textSize = 60.0F\r\n        typeface = Typeface.create(\"serif-monospace\", Typeface.BOLD)\r\n    }\r\n    private var buttonPauseText = context.getString(R.string.pauseText)\r\n\r\n    init {\r\n        if (mHolder != null) {\r\n            mHolder?.addCallback(this)\r\n        }\r\n\r\n        // Score-text-färg-attribut\r\n        scorePaint = Paint().apply {\r\n            color = Color.GREEN\r\n            alpha = 200\r\n            textSize = 60.0F\r\n            typeface = Typeface.create(\"serif-monospace\", Typeface.BOLD)\r\n        }\r\n        textGameOverPaint = Paint().apply {\r\n            color = Color.RED\r\n            alpha = 200\r\n            textSize = 60.0F\r\n            typeface = Typeface.create(\"serif-monospace\", Typeface.BOLD)\r\n        }\r\n        // Enbart för att synliggöra gränserna\r\n        lineColor = Paint().apply {\r\n            color = Color.MAGENTA\r\n            style = Paint.Style.STROKE\r\n            strokeWidth = 10f\r\n        }\r\n        touchColor = Paint().apply {\r\n            color = Color.RED\r\n            style = Paint.Style.STROKE\r\n            strokeWidth = 50f\r\n        }\r\n        setup()\r\n    }\r\n\r\n    @SuppressLint(\"UseCompatLoadingForDrawables\")\r\n    private fun setup() {\r\n\r\n        ballSquash = BallSquash(this.context, 100f, 100f, 30f, 20f, 20f, Color.RED, 20f)\r\n\r\n        // val drawablePaddle = resources.getDrawable(R.drawable.player_pad_a, null)\r\n        squashPad = SquashPad(\r\n            this.context, 50f, 400f, 6f, 0f, 0f, 0,\r\n            15f, 75f, 0f\r\n        )\r\n    }\r\n\r\n    fun start() {\r\n        running = true\r\n        thread =\r\n            Thread(this) //en trad har en konstruktor som tar in en runnable,\r\n        // vilket sker i denna klass se rad 10\r\n        thread?.start()\r\n\r\n    }\r\n\r\n    fun stop() {\r\n        running = false\r\n        try {\r\n            thread?.join() //join betyder att huvudtraden komemr vanta in att traden dor ut av sig sjalv\r\n        } catch (e: InterruptedException) {\r\n            e.printStackTrace()\r\n        }\r\n    }\r\n\r\n    fun update() { //bounce sounds utanfor spelplanen nar fatt gameOver. Pauseknappen borde vara nere\r\n        ballIntersects(ballSquash, squashPad)\r\n        val screenHeight = height // Höjden på skärmen\r\n        ballSquash.update()\r\n        // Räknar bara när boll rör långsidan just nu\r\n        if (ballSquash.ballPositionX > width - ballSquash.ballSize) {\r\n            updateScore()\r\n            soundEffect.play(4) //ljudeffekt när boll rör långsidan\r\n        }\r\n        if (ballSquash.ballPositionY > height - ballSquash.ballSize) {\r\n            soundEffect.play(4) //ljudeffekt när boll rör golvet\r\n        }\r\n        if (ballSquash.ballPositionY < 0 + ballSquash.ballSize) {\r\n            soundEffect.play(4) //ljudeffekt när boll rör golvet\r\n        }\r\n    }\r\n\r\n    override fun run() {\r\n        while (running) {\r\n            if (!isPaused) {\r\n                try {\r\n                    update()\r\n                    drawGameBounds(holder)\r\n                    ballSquash.checkBounds(bounds)\r\n                } catch (e: Exception) {\r\n                    e.printStackTrace()\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //med denna kod kan jag rora pa boll2 som star stilla annars\r\n    @SuppressLint(\"ClickableViewAccessibility\")\r\n    override fun onTouchEvent(event: MotionEvent?): Boolean {\r\n        if (event != null) {\r\n            val x = event.x.toInt()\r\n            val y = event.y.toInt()\r\n            if (!isInsidePauseRectangule(x, y)) {\r\n                // User is not clicking on pause\r\n                squashPad.ballPositionY = event.y // Move pad\r\n            } else if (isInsidePauseRectangule(x, y) && event.action == MotionEvent.ACTION_DOWN) {\r\n                // User is clicking on Pause\r\n                buttonPauseText = if (isPaused) context.getString(R.string.pauseText)\r\n                else context.getString(R.string.resumeText)\r\n                isPaused = !isPaused\r\n                drawGameBounds(holder)\r\n            }\r\n            return true\r\n        }\r\n        return super.onTouchEvent(event)\r\n    }\r\n\r\n    private fun isInsidePauseRectangule(x: Int, y: Int) = buttonPauseRect!!.contains(x, y)\r\n\r\n    //onBallCollision inverterar riktningen på bollen när den träffar squashPad\r\n// denna funktionen beräknar avstånd från bollens Y position och padelns Y position för att\r\n// bestämma vart på padeln som bollen träffar.\r\n// sen bestäms studsriktningen beroende på vart på padeln kollisionen sker\r\n// sen så räknas vinkeln genom multiplicera normaliserade värdet.\r\n    fun onBallCollision(ballSquash1: BallSquash, squashPad: SquashPad) {\r\n\r\n        val relativeIntersectY = squashPad.ballPositionY - ballSquash1.ballPositionY\r\n        val normalizedIntersectY = (relativeIntersectY / (squashPad.height / 2)).coerceIn(-1f, 1f)\r\n        val bounceAngle =\r\n            normalizedIntersectY * Math.PI / 7\r\n\r\n        val randomSpeed = (15..45).random().toFloat()\r\n        ballSquash1.ballSpeedX = (randomSpeed * Math.cos(bounceAngle)).toFloat()\r\n        ballSquash1.ballSpeedY = (-randomSpeed * Math.sin(bounceAngle)).toFloat()\r\n        // För att få slumpmässig hastighet vid kollision mellan boll o paddel ta koden ↑\r\n        //För att ha en hastighet så ta koden ↓\r\n//        ballSquash1.ballSpeedX = (ballSquash1.speed * Math.cos(bounceAngle)).toFloat()\r\n//        ballSquash1.ballSpeedY = (-ballSquash1.speed * Math.sin(bounceAngle)).toFloat()\r\n    }\r\n\r\n    // här tar vi in storlek från ball och squashPad och kontrollerar när en kollision sker\r\n    fun ballIntersects(ballSquash1: BallSquash, squashPad: SquashPad) {\r\n        val padLeft = squashPad.ballPositionX - squashPad.width\r\n        val padRight = squashPad.ballPositionX + squashPad.width\r\n        val padTop = squashPad.ballPositionY - squashPad.height\r\n        val padBottom = squashPad.ballPositionY + squashPad.height\r\n        val ballLeft = ballSquash1.ballPositionX - ballSquash1.ballSize\r\n        val ballRight = ballSquash1.ballPositionX + ballSquash1.ballSize\r\n        val ballTop = ballSquash1.ballPositionY - ballSquash1.ballSize\r\n        val ballBottom = ballSquash1.ballPositionY + ballSquash1.ballSize\r\n\r\n        if (ballRight >= padLeft && ballLeft <= padRight && ballBottom >= padTop && ballTop <=\r\n            padBottom\r\n        ) {\r\n            onBallCollision(ballSquash1, squashPad)\r\n            soundEffect.play(5) //ljudeffekt när boll rör pad\r\n        }\r\n    }\r\n\r\n\r\n    //dessa startar och stoppar min thread:\r\n    override fun surfaceCreated(holder: SurfaceHolder) {\r\n    }\r\n\r\n    override fun surfaceChanged(holder: SurfaceHolder, format: Int, width: Int, height: Int) {\r\n        gameBoundaryPath = createBoundaryPath(width, height)\r\n        bounds = Rect(0, 0, width, height)\r\n        start()\r\n    }\r\n\r\n    override fun surfaceDestroyed(holder: SurfaceHolder) {\r\n        stop()\r\n    }\r\n\r\n    //run/metoden ar en metod som vi fick fran interface Runnable och ar kopplat till dess Thread.\r\n    // Run anropas nar vi kor Thread.start()\r\n    //den kor en while loop med vår running variable och anropar update och draw:\r\n\r\n\r\n    fun drawGameBounds(holder: SurfaceHolder) {\r\n        val canvas: Canvas? = holder.lockCanvas()\r\n        canvas?.drawColor(Color.BLACK)\r\n\r\n        gameBoundaryPath?.let {\r\n            canvas?.drawPath(it, lineColor)\r\n\r\n            if (isGameOver()) {\r\n                // User loses\r\n                canvas?.drawPath(it, touchColor)\r\n                canvas?.drawText(\r\n                    \"Score: $score\",\r\n                    canvas.width.toFloat() - 400,\r\n                    0f + 100,\r\n                    textGameOverPaint\r\n                )\r\n                canvas?.drawText(\r\n                    \"GAME OVER\",\r\n                    canvas.width.toFloat() / 3,\r\n                    canvas.height.toFloat() / 2,\r\n                    textGameOverPaint\r\n                )\r\n\r\n                // Save score\r\n                val sharedPreferencesManager: DataManager = SharedPreferencesManager(context)\r\n                sharedPreferencesManager.addNewScore(DataManager.Score(this.userName, score, DataManager.Game.SQUASH))\r\n            } else if (isGameWon) {\r\n                // Player wins\r\n                canvas?.drawText(\r\n                    \"Congratz! You Won\",\r\n                    canvas.width.toFloat() / 6,\r\n                    canvas.height.toFloat() / 2,\r\n                    textGameOverPaint\r\n                )\r\n                // Save score\r\n                val sharedPreferencesManager: DataManager = SharedPreferencesManager(context)\r\n                sharedPreferencesManager.addNewScore(DataManager.Score(this.userName, score, DataManager.Game.SQUASH))\r\n\r\n                // Unlock and post canvas before stopping the game\r\n                holder.unlockCanvasAndPost(canvas)\r\n\r\n                stop() // Stop the game\r\n                return // Return early to prevent further drawing\r\n            } else {\r\n                // Normal gameplay score display\r\n                canvas?.drawText(\r\n                    \"Score: $score\",\r\n                    canvas.width.toFloat() - 400,\r\n                    0f + 100,\r\n                    scorePaint\r\n                )\r\n            }\r\n        }\r\n\r\n        ballSquash.draw(canvas)\r\n        squashPad.draw(canvas)\r\n\r\n        // Draw pause button\r\n        if (canvas != null) {\r\n            val buttonPauseTextLength = buttonPauseTextPaint.measureText(buttonPauseText)\r\n            buttonPauseRect = Rect(\r\n                (canvas.width.toFloat() - 650f).toInt(),\r\n                0 + 50,\r\n                (canvas.width.toFloat() - 650f + buttonPauseTextLength + 10).toInt(),\r\n                50 + textGameOverPaint.textSize.toInt()\r\n            )\r\n\r\n            canvas.drawRect(buttonPauseRect!!, buttonPausePaint)\r\n            canvas.drawText(\r\n                buttonPauseText,\r\n                buttonPauseRect!!.left.toFloat() + 5,\r\n                buttonPauseRect!!.top.toFloat() + buttonPauseTextPaint.textSize - 10,\r\n                buttonPauseTextPaint\r\n            )\r\n        }\r\n\r\n        holder.unlockCanvasAndPost(canvas)\r\n    }\r\n\r\n\r\n    private fun isGameOver() = ballSquash.ballPositionX < 0 - ballSquash.ballSize\r\n\r\n    // För syns skull gör en Path med färgade linjer för gränserna.\r\n    private fun createBoundaryPath(width: Int, height: Int): Path {\r\n        val path = Path()\r\n        path.moveTo(0f, 0f)\r\n        path.lineTo(width.toFloat(), 0f)\r\n        path.lineTo(width.toFloat(), height.toFloat())\r\n        path.lineTo(0f, height.toFloat())\r\n        return path\r\n    }\r\n\r\n    private var isGameWon = false\r\n\r\n    private fun updateScore(): Int {\r\n        score++\r\n        if (score >= 15) {\r\n            isGameWon = true\r\n            soundEffect.play(9)\r\n        }\r\n        return score\r\n    }\r\n}\r\n\r\n//        if ()\r\n//        {\r\n//            ballSquash1.ballSpeedY *= -1\r\n//            ballSquash1.ballSpeedX= (10..30).random().toFloat()\r\n//        }
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/app/src/main/java/com/example/racoonsquash/SquashGameView.kt b/app/src/main/java/com/example/racoonsquash/SquashGameView.kt
--- a/app/src/main/java/com/example/racoonsquash/SquashGameView.kt	(revision aafe0228f59aa0e6292c61bff020eb901850b797)
+++ b/app/src/main/java/com/example/racoonsquash/SquashGameView.kt	(date 1705053991198)
@@ -13,7 +13,8 @@
 import android.view.SurfaceView
 
 
-class SquashGameView(context: Context, private val userName: String) : SurfaceView(context), SurfaceHolder.Callback, Runnable {
+class SquashGameView(context: Context, private val userName: String) : SurfaceView(context),
+    SurfaceHolder.Callback, Runnable {
     var thread: Thread? = null
     private var running = false
     lateinit var ballSquash: BallSquash
@@ -32,7 +33,7 @@
     var bounds = Rect() //for att kunna studsa m vaggarna
     var mHolder: SurfaceHolder? = holder
 
-    private var buttonPauseRect :Rect? = null
+    private var buttonPauseRect: Rect? = null
     private val buttonPausePaint = Paint().apply {
         //This could be transparent if no rectangle is wanted to be shown
         color = Color.YELLOW
@@ -173,6 +174,7 @@
         val bounceAngle =
             normalizedIntersectY * Math.PI / 7
 
+
         val randomSpeed = (15..45).random().toFloat()
         ballSquash1.ballSpeedX = (randomSpeed * Math.cos(bounceAngle)).toFloat()
         ballSquash1.ballSpeedY = (-randomSpeed * Math.sin(bounceAngle)).toFloat()
@@ -246,7 +248,13 @@
 
                 // Save score
                 val sharedPreferencesManager: DataManager = SharedPreferencesManager(context)
-                sharedPreferencesManager.addNewScore(DataManager.Score(this.userName, score, DataManager.Game.SQUASH))
+                sharedPreferencesManager.addNewScore(
+                    DataManager.Score(
+                        this.userName,
+                        score,
+                        DataManager.Game.SQUASH
+                    )
+                )
             } else if (isGameWon) {
                 // Player wins
                 canvas?.drawText(
@@ -257,7 +265,13 @@
                 )
                 // Save score
                 val sharedPreferencesManager: DataManager = SharedPreferencesManager(context)
-                sharedPreferencesManager.addNewScore(DataManager.Score(this.userName, score, DataManager.Game.SQUASH))
+                sharedPreferencesManager.addNewScore(
+                    DataManager.Score(
+                        this.userName,
+                        score,
+                        DataManager.Game.SQUASH
+                    )
+                )
 
                 // Unlock and post canvas before stopping the game
                 holder.unlockCanvasAndPost(canvas)
